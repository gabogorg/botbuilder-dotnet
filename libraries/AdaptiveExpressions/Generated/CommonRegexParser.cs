//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.8
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from CommonRegex.g4 by ANTLR 4.8

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419


#pragma warning disable 3021 // Disable StyleCop warning CS3021 re CLSCompliant attribute in generated files.
#pragma warning disable 0108 // Disable StyleCop warning CS0108, hides inherited member in generated files.

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.8")]
[System.CLSCompliant(false)]
public partial class CommonRegexParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Quoted=1, BlockQuoted=2, BellChar=3, ControlChar=4, EscapeChar=5, FormFeed=6, 
		NewLine=7, CarriageReturn=8, Tab=9, Backslash=10, HexChar=11, Dot=12, 
		DecimalDigit=13, NotDecimalDigit=14, CharWithProperty=15, CharWithoutProperty=16, 
		WhiteSpace=17, NotWhiteSpace=18, WordChar=19, NotWordChar=20, CharacterClassStart=21, 
		CharacterClassEnd=22, Caret=23, Hyphen=24, QuestionMark=25, Plus=26, Star=27, 
		OpenBrace=28, CloseBrace=29, Comma=30, EndOfSubject=31, Pipe=32, OpenParen=33, 
		CloseParen=34, LessThan=35, GreaterThan=36, SingleQuote=37, Underscore=38, 
		Colon=39, Hash=40, Equals=41, Exclamation=42, Ampersand=43, ALC=44, BLC=45, 
		CLC=46, DLC=47, ELC=48, FLC=49, GLC=50, HLC=51, ILC=52, JLC=53, KLC=54, 
		LLC=55, MLC=56, NLC=57, OLC=58, PLC=59, QLC=60, RLC=61, SLC=62, TLC=63, 
		ULC=64, VLC=65, WLC=66, XLC=67, YLC=68, ZLC=69, AUC=70, BUC=71, CUC=72, 
		DUC=73, EUC=74, FUC=75, GUC=76, HUC=77, IUC=78, JUC=79, KUC=80, LUC=81, 
		MUC=82, NUC=83, OUC=84, PUC=85, QUC=86, RUC=87, SUC=88, TUC=89, UUC=90, 
		VUC=91, WUC=92, XUC=93, YUC=94, ZUC=95, D1=96, D2=97, D3=98, D4=99, D5=100, 
		D6=101, D7=102, D8=103, D9=104, D0=105, OtherChar=106;
	public const int
		RULE_parse = 0, RULE_alternation = 1, RULE_expr = 2, RULE_element = 3, 
		RULE_quantifier = 4, RULE_quantifier_type = 5, RULE_character_class = 6, 
		RULE_capture = 7, RULE_non_capture = 8, RULE_option = 9, RULE_option_flag = 10, 
		RULE_atom = 11, RULE_cc_atom = 12, RULE_shared_atom = 13, RULE_literal = 14, 
		RULE_cc_literal = 15, RULE_shared_literal = 16, RULE_number = 17, RULE_octal_char = 18, 
		RULE_octal_digit = 19, RULE_digits = 20, RULE_digit = 21, RULE_name = 22, 
		RULE_alpha_nums = 23, RULE_non_close_parens = 24, RULE_non_close_paren = 25, 
		RULE_letter = 26;
	public static readonly string[] ruleNames = {
		"parse", "alternation", "expr", "element", "quantifier", "quantifier_type", 
		"character_class", "capture", "non_capture", "option", "option_flag", 
		"atom", "cc_atom", "shared_atom", "literal", "cc_literal", "shared_literal", 
		"number", "octal_char", "octal_digit", "digits", "digit", "name", "alpha_nums", 
		"non_close_parens", "non_close_paren", "letter"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, "'\\a'", "'\\c'", "'\\e'", "'\\f'", "'\\n'", "'\\r'", 
		"'\\t'", "'\\'", null, "'.'", "'\\d'", "'\\D'", null, null, "'\\s'", "'\\S'", 
		"'\\w'", "'\\W'", "'['", "']'", "'^'", "'-'", "'?'", "'+'", "'*'", "'{'", 
		"'}'", "','", "'$'", "'|'", "'('", "')'", "'<'", "'>'", "'''", "'_'", 
		"':'", "'#'", "'='", "'!'", "'&'", "'a'", "'b'", "'c'", "'d'", "'e'", 
		"'f'", "'g'", "'h'", "'i'", "'j'", "'k'", "'l'", "'m'", "'n'", "'o'", 
		"'p'", "'q'", "'r'", "'s'", "'t'", "'u'", "'v'", "'w'", "'x'", "'y'", 
		"'z'", "'A'", "'B'", "'C'", "'D'", "'E'", "'F'", "'G'", "'H'", "'I'", 
		"'J'", "'K'", "'L'", "'M'", "'N'", "'O'", "'P'", "'Q'", "'R'", "'S'", 
		"'T'", "'U'", "'V'", "'W'", "'X'", "'Y'", "'Z'", "'1'", "'2'", "'3'", 
		"'4'", "'5'", "'6'", "'7'", "'8'", "'9'", "'0'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Quoted", "BlockQuoted", "BellChar", "ControlChar", "EscapeChar", 
		"FormFeed", "NewLine", "CarriageReturn", "Tab", "Backslash", "HexChar", 
		"Dot", "DecimalDigit", "NotDecimalDigit", "CharWithProperty", "CharWithoutProperty", 
		"WhiteSpace", "NotWhiteSpace", "WordChar", "NotWordChar", "CharacterClassStart", 
		"CharacterClassEnd", "Caret", "Hyphen", "QuestionMark", "Plus", "Star", 
		"OpenBrace", "CloseBrace", "Comma", "EndOfSubject", "Pipe", "OpenParen", 
		"CloseParen", "LessThan", "GreaterThan", "SingleQuote", "Underscore", 
		"Colon", "Hash", "Equals", "Exclamation", "Ampersand", "ALC", "BLC", "CLC", 
		"DLC", "ELC", "FLC", "GLC", "HLC", "ILC", "JLC", "KLC", "LLC", "MLC", 
		"NLC", "OLC", "PLC", "QLC", "RLC", "SLC", "TLC", "ULC", "VLC", "WLC", 
		"XLC", "YLC", "ZLC", "AUC", "BUC", "CUC", "DUC", "EUC", "FUC", "GUC", 
		"HUC", "IUC", "JUC", "KUC", "LUC", "MUC", "NUC", "OUC", "PUC", "QUC", 
		"RUC", "SUC", "TUC", "UUC", "VUC", "WUC", "XUC", "YUC", "ZUC", "D1", "D2", 
		"D3", "D4", "D5", "D6", "D7", "D8", "D9", "D0", "OtherChar"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "CommonRegex.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static CommonRegexParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public CommonRegexParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public CommonRegexParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ParseContext : ParserRuleContext {
		public AlternationContext alternation() {
			return GetRuleContext<AlternationContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(CommonRegexParser.Eof, 0); }
		public ParseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parse; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterParse(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitParse(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParse(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParseContext parse() {
		ParseContext _localctx = new ParseContext(Context, State);
		EnterRule(_localctx, 0, RULE_parse);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 54; alternation();
			State = 55; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlternationContext : ParserRuleContext {
		public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public ITerminalNode[] Pipe() { return GetTokens(CommonRegexParser.Pipe); }
		public ITerminalNode Pipe(int i) {
			return GetToken(CommonRegexParser.Pipe, i);
		}
		public AlternationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alternation; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterAlternation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitAlternation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlternation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlternationContext alternation() {
		AlternationContext _localctx = new AlternationContext(Context, State);
		EnterRule(_localctx, 2, RULE_alternation);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 57; expr();
			State = 62;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Pipe) {
				{
				{
				State = 58; Match(Pipe);
				State = 59; expr();
				}
				}
				State = 64;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprContext : ParserRuleContext {
		public ElementContext[] element() {
			return GetRuleContexts<ElementContext>();
		}
		public ElementContext element(int i) {
			return GetRuleContext<ElementContext>(i);
		}
		public ExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterExpr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitExpr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprContext expr() {
		ExprContext _localctx = new ExprContext(Context, State);
		EnterRule(_localctx, 4, RULE_expr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 68;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Quoted) | (1L << BlockQuoted) | (1L << BellChar) | (1L << ControlChar) | (1L << EscapeChar) | (1L << FormFeed) | (1L << NewLine) | (1L << CarriageReturn) | (1L << Tab) | (1L << Backslash) | (1L << HexChar) | (1L << Dot) | (1L << DecimalDigit) | (1L << NotDecimalDigit) | (1L << CharWithProperty) | (1L << CharWithoutProperty) | (1L << WhiteSpace) | (1L << NotWhiteSpace) | (1L << WordChar) | (1L << NotWordChar) | (1L << CharacterClassStart) | (1L << CharacterClassEnd) | (1L << Caret) | (1L << Hyphen) | (1L << OpenBrace) | (1L << CloseBrace) | (1L << Comma) | (1L << EndOfSubject) | (1L << OpenParen) | (1L << LessThan) | (1L << GreaterThan) | (1L << SingleQuote) | (1L << Underscore) | (1L << Colon) | (1L << Hash) | (1L << Equals) | (1L << Exclamation) | (1L << Ampersand) | (1L << ALC) | (1L << BLC) | (1L << CLC) | (1L << DLC) | (1L << ELC) | (1L << FLC) | (1L << GLC) | (1L << HLC) | (1L << ILC) | (1L << JLC) | (1L << KLC) | (1L << LLC) | (1L << MLC) | (1L << NLC) | (1L << OLC) | (1L << PLC) | (1L << QLC) | (1L << RLC) | (1L << SLC) | (1L << TLC))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (ULC - 64)) | (1L << (VLC - 64)) | (1L << (WLC - 64)) | (1L << (XLC - 64)) | (1L << (YLC - 64)) | (1L << (ZLC - 64)) | (1L << (AUC - 64)) | (1L << (BUC - 64)) | (1L << (CUC - 64)) | (1L << (DUC - 64)) | (1L << (EUC - 64)) | (1L << (FUC - 64)) | (1L << (GUC - 64)) | (1L << (HUC - 64)) | (1L << (IUC - 64)) | (1L << (JUC - 64)) | (1L << (KUC - 64)) | (1L << (LUC - 64)) | (1L << (MUC - 64)) | (1L << (NUC - 64)) | (1L << (OUC - 64)) | (1L << (PUC - 64)) | (1L << (QUC - 64)) | (1L << (RUC - 64)) | (1L << (SUC - 64)) | (1L << (TUC - 64)) | (1L << (UUC - 64)) | (1L << (VUC - 64)) | (1L << (WUC - 64)) | (1L << (XUC - 64)) | (1L << (YUC - 64)) | (1L << (ZUC - 64)) | (1L << (D1 - 64)) | (1L << (D2 - 64)) | (1L << (D3 - 64)) | (1L << (D4 - 64)) | (1L << (D5 - 64)) | (1L << (D6 - 64)) | (1L << (D7 - 64)) | (1L << (D8 - 64)) | (1L << (D9 - 64)) | (1L << (D0 - 64)) | (1L << (OtherChar - 64)))) != 0)) {
				{
				{
				State = 65; element();
				}
				}
				State = 70;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementContext : ParserRuleContext {
		public AtomContext atom() {
			return GetRuleContext<AtomContext>(0);
		}
		public QuantifierContext quantifier() {
			return GetRuleContext<QuantifierContext>(0);
		}
		public ElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterElement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitElement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementContext element() {
		ElementContext _localctx = new ElementContext(Context, State);
		EnterRule(_localctx, 6, RULE_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 71; atom();
			State = 73;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
			case 1:
				{
				State = 72; quantifier();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QuantifierContext : ParserRuleContext {
		public ITerminalNode QuestionMark() { return GetToken(CommonRegexParser.QuestionMark, 0); }
		public Quantifier_typeContext quantifier_type() {
			return GetRuleContext<Quantifier_typeContext>(0);
		}
		public ITerminalNode Plus() { return GetToken(CommonRegexParser.Plus, 0); }
		public ITerminalNode Star() { return GetToken(CommonRegexParser.Star, 0); }
		public ITerminalNode OpenBrace() { return GetToken(CommonRegexParser.OpenBrace, 0); }
		public NumberContext[] number() {
			return GetRuleContexts<NumberContext>();
		}
		public NumberContext number(int i) {
			return GetRuleContext<NumberContext>(i);
		}
		public ITerminalNode CloseBrace() { return GetToken(CommonRegexParser.CloseBrace, 0); }
		public ITerminalNode Comma() { return GetToken(CommonRegexParser.Comma, 0); }
		public QuantifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quantifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterQuantifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitQuantifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuantifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QuantifierContext quantifier() {
		QuantifierContext _localctx = new QuantifierContext(Context, State);
		EnterRule(_localctx, 8, RULE_quantifier);
		try {
			State = 99;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 75; Match(QuestionMark);
				State = 76; quantifier_type();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 77; Match(Plus);
				State = 78; quantifier_type();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 79; Match(Star);
				State = 80; quantifier_type();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 81; Match(OpenBrace);
				State = 82; number();
				State = 83; Match(CloseBrace);
				State = 84; quantifier_type();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 86; Match(OpenBrace);
				State = 87; number();
				State = 88; Match(Comma);
				State = 89; Match(CloseBrace);
				State = 90; quantifier_type();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 92; Match(OpenBrace);
				State = 93; number();
				State = 94; Match(Comma);
				State = 95; number();
				State = 96; Match(CloseBrace);
				State = 97; quantifier_type();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Quantifier_typeContext : ParserRuleContext {
		public ITerminalNode Plus() { return GetToken(CommonRegexParser.Plus, 0); }
		public ITerminalNode QuestionMark() { return GetToken(CommonRegexParser.QuestionMark, 0); }
		public Quantifier_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quantifier_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterQuantifier_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitQuantifier_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuantifier_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Quantifier_typeContext quantifier_type() {
		Quantifier_typeContext _localctx = new Quantifier_typeContext(Context, State);
		EnterRule(_localctx, 10, RULE_quantifier_type);
		try {
			State = 104;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Plus:
				EnterOuterAlt(_localctx, 1);
				{
				State = 101; Match(Plus);
				}
				break;
			case QuestionMark:
				EnterOuterAlt(_localctx, 2);
				{
				State = 102; Match(QuestionMark);
				}
				break;
			case Eof:
			case Quoted:
			case BlockQuoted:
			case BellChar:
			case ControlChar:
			case EscapeChar:
			case FormFeed:
			case NewLine:
			case CarriageReturn:
			case Tab:
			case Backslash:
			case HexChar:
			case Dot:
			case DecimalDigit:
			case NotDecimalDigit:
			case CharWithProperty:
			case CharWithoutProperty:
			case WhiteSpace:
			case NotWhiteSpace:
			case WordChar:
			case NotWordChar:
			case CharacterClassStart:
			case CharacterClassEnd:
			case Caret:
			case Hyphen:
			case OpenBrace:
			case CloseBrace:
			case Comma:
			case EndOfSubject:
			case Pipe:
			case OpenParen:
			case CloseParen:
			case LessThan:
			case GreaterThan:
			case SingleQuote:
			case Underscore:
			case Colon:
			case Hash:
			case Equals:
			case Exclamation:
			case Ampersand:
			case ALC:
			case BLC:
			case CLC:
			case DLC:
			case ELC:
			case FLC:
			case GLC:
			case HLC:
			case ILC:
			case JLC:
			case KLC:
			case LLC:
			case MLC:
			case NLC:
			case OLC:
			case PLC:
			case QLC:
			case RLC:
			case SLC:
			case TLC:
			case ULC:
			case VLC:
			case WLC:
			case XLC:
			case YLC:
			case ZLC:
			case AUC:
			case BUC:
			case CUC:
			case DUC:
			case EUC:
			case FUC:
			case GUC:
			case HUC:
			case IUC:
			case JUC:
			case KUC:
			case LUC:
			case MUC:
			case NUC:
			case OUC:
			case PUC:
			case QUC:
			case RUC:
			case SUC:
			case TUC:
			case UUC:
			case VUC:
			case WUC:
			case XUC:
			case YUC:
			case ZUC:
			case D1:
			case D2:
			case D3:
			case D4:
			case D5:
			case D6:
			case D7:
			case D8:
			case D9:
			case D0:
			case OtherChar:
				EnterOuterAlt(_localctx, 3);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Character_classContext : ParserRuleContext {
		public ITerminalNode CharacterClassStart() { return GetToken(CommonRegexParser.CharacterClassStart, 0); }
		public ITerminalNode Caret() { return GetToken(CommonRegexParser.Caret, 0); }
		public ITerminalNode CharacterClassEnd() { return GetToken(CommonRegexParser.CharacterClassEnd, 0); }
		public Cc_atomContext[] cc_atom() {
			return GetRuleContexts<Cc_atomContext>();
		}
		public Cc_atomContext cc_atom(int i) {
			return GetRuleContext<Cc_atomContext>(i);
		}
		public Character_classContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_character_class; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterCharacter_class(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitCharacter_class(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCharacter_class(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Character_classContext character_class() {
		Character_classContext _localctx = new Character_classContext(Context, State);
		EnterRule(_localctx, 12, RULE_character_class);
		int _la;
		try {
			State = 123;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,7,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 106; Match(CharacterClassStart);
				State = 107; Match(Caret);
				State = 109;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 108; cc_atom();
					}
					}
					State = 111;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Quoted) | (1L << BlockQuoted) | (1L << BellChar) | (1L << ControlChar) | (1L << EscapeChar) | (1L << FormFeed) | (1L << NewLine) | (1L << CarriageReturn) | (1L << Tab) | (1L << Backslash) | (1L << HexChar) | (1L << Dot) | (1L << DecimalDigit) | (1L << NotDecimalDigit) | (1L << CharWithProperty) | (1L << CharWithoutProperty) | (1L << WhiteSpace) | (1L << NotWhiteSpace) | (1L << WordChar) | (1L << NotWordChar) | (1L << CharacterClassStart) | (1L << Caret) | (1L << Hyphen) | (1L << QuestionMark) | (1L << Plus) | (1L << Star) | (1L << OpenBrace) | (1L << CloseBrace) | (1L << Comma) | (1L << EndOfSubject) | (1L << Pipe) | (1L << OpenParen) | (1L << CloseParen) | (1L << LessThan) | (1L << GreaterThan) | (1L << SingleQuote) | (1L << Underscore) | (1L << Colon) | (1L << Hash) | (1L << Equals) | (1L << Exclamation) | (1L << Ampersand) | (1L << ALC) | (1L << BLC) | (1L << CLC) | (1L << DLC) | (1L << ELC) | (1L << FLC) | (1L << GLC) | (1L << HLC) | (1L << ILC) | (1L << JLC) | (1L << KLC) | (1L << LLC) | (1L << MLC) | (1L << NLC) | (1L << OLC) | (1L << PLC) | (1L << QLC) | (1L << RLC) | (1L << SLC) | (1L << TLC))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (ULC - 64)) | (1L << (VLC - 64)) | (1L << (WLC - 64)) | (1L << (XLC - 64)) | (1L << (YLC - 64)) | (1L << (ZLC - 64)) | (1L << (AUC - 64)) | (1L << (BUC - 64)) | (1L << (CUC - 64)) | (1L << (DUC - 64)) | (1L << (EUC - 64)) | (1L << (FUC - 64)) | (1L << (GUC - 64)) | (1L << (HUC - 64)) | (1L << (IUC - 64)) | (1L << (JUC - 64)) | (1L << (KUC - 64)) | (1L << (LUC - 64)) | (1L << (MUC - 64)) | (1L << (NUC - 64)) | (1L << (OUC - 64)) | (1L << (PUC - 64)) | (1L << (QUC - 64)) | (1L << (RUC - 64)) | (1L << (SUC - 64)) | (1L << (TUC - 64)) | (1L << (UUC - 64)) | (1L << (VUC - 64)) | (1L << (WUC - 64)) | (1L << (XUC - 64)) | (1L << (YUC - 64)) | (1L << (ZUC - 64)) | (1L << (D1 - 64)) | (1L << (D2 - 64)) | (1L << (D3 - 64)) | (1L << (D4 - 64)) | (1L << (D5 - 64)) | (1L << (D6 - 64)) | (1L << (D7 - 64)) | (1L << (D8 - 64)) | (1L << (D9 - 64)) | (1L << (D0 - 64)) | (1L << (OtherChar - 64)))) != 0) );
				State = 113; Match(CharacterClassEnd);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 115; Match(CharacterClassStart);
				State = 117;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 116; cc_atom();
					}
					}
					State = 119;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Quoted) | (1L << BlockQuoted) | (1L << BellChar) | (1L << ControlChar) | (1L << EscapeChar) | (1L << FormFeed) | (1L << NewLine) | (1L << CarriageReturn) | (1L << Tab) | (1L << Backslash) | (1L << HexChar) | (1L << Dot) | (1L << DecimalDigit) | (1L << NotDecimalDigit) | (1L << CharWithProperty) | (1L << CharWithoutProperty) | (1L << WhiteSpace) | (1L << NotWhiteSpace) | (1L << WordChar) | (1L << NotWordChar) | (1L << CharacterClassStart) | (1L << Caret) | (1L << Hyphen) | (1L << QuestionMark) | (1L << Plus) | (1L << Star) | (1L << OpenBrace) | (1L << CloseBrace) | (1L << Comma) | (1L << EndOfSubject) | (1L << Pipe) | (1L << OpenParen) | (1L << CloseParen) | (1L << LessThan) | (1L << GreaterThan) | (1L << SingleQuote) | (1L << Underscore) | (1L << Colon) | (1L << Hash) | (1L << Equals) | (1L << Exclamation) | (1L << Ampersand) | (1L << ALC) | (1L << BLC) | (1L << CLC) | (1L << DLC) | (1L << ELC) | (1L << FLC) | (1L << GLC) | (1L << HLC) | (1L << ILC) | (1L << JLC) | (1L << KLC) | (1L << LLC) | (1L << MLC) | (1L << NLC) | (1L << OLC) | (1L << PLC) | (1L << QLC) | (1L << RLC) | (1L << SLC) | (1L << TLC))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (ULC - 64)) | (1L << (VLC - 64)) | (1L << (WLC - 64)) | (1L << (XLC - 64)) | (1L << (YLC - 64)) | (1L << (ZLC - 64)) | (1L << (AUC - 64)) | (1L << (BUC - 64)) | (1L << (CUC - 64)) | (1L << (DUC - 64)) | (1L << (EUC - 64)) | (1L << (FUC - 64)) | (1L << (GUC - 64)) | (1L << (HUC - 64)) | (1L << (IUC - 64)) | (1L << (JUC - 64)) | (1L << (KUC - 64)) | (1L << (LUC - 64)) | (1L << (MUC - 64)) | (1L << (NUC - 64)) | (1L << (OUC - 64)) | (1L << (PUC - 64)) | (1L << (QUC - 64)) | (1L << (RUC - 64)) | (1L << (SUC - 64)) | (1L << (TUC - 64)) | (1L << (UUC - 64)) | (1L << (VUC - 64)) | (1L << (WUC - 64)) | (1L << (XUC - 64)) | (1L << (YUC - 64)) | (1L << (ZUC - 64)) | (1L << (D1 - 64)) | (1L << (D2 - 64)) | (1L << (D3 - 64)) | (1L << (D4 - 64)) | (1L << (D5 - 64)) | (1L << (D6 - 64)) | (1L << (D7 - 64)) | (1L << (D8 - 64)) | (1L << (D9 - 64)) | (1L << (D0 - 64)) | (1L << (OtherChar - 64)))) != 0) );
				State = 121; Match(CharacterClassEnd);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaptureContext : ParserRuleContext {
		public ITerminalNode OpenParen() { return GetToken(CommonRegexParser.OpenParen, 0); }
		public ITerminalNode QuestionMark() { return GetToken(CommonRegexParser.QuestionMark, 0); }
		public ITerminalNode LessThan() { return GetToken(CommonRegexParser.LessThan, 0); }
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public ITerminalNode GreaterThan() { return GetToken(CommonRegexParser.GreaterThan, 0); }
		public AlternationContext alternation() {
			return GetRuleContext<AlternationContext>(0);
		}
		public ITerminalNode CloseParen() { return GetToken(CommonRegexParser.CloseParen, 0); }
		public CaptureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_capture; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterCapture(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitCapture(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCapture(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaptureContext capture() {
		CaptureContext _localctx = new CaptureContext(Context, State);
		EnterRule(_localctx, 14, RULE_capture);
		try {
			State = 137;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,8,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 125; Match(OpenParen);
				State = 126; Match(QuestionMark);
				State = 127; Match(LessThan);
				State = 128; name();
				State = 129; Match(GreaterThan);
				State = 130; alternation();
				State = 131; Match(CloseParen);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 133; Match(OpenParen);
				State = 134; alternation();
				State = 135; Match(CloseParen);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_captureContext : ParserRuleContext {
		public ITerminalNode OpenParen() { return GetToken(CommonRegexParser.OpenParen, 0); }
		public ITerminalNode QuestionMark() { return GetToken(CommonRegexParser.QuestionMark, 0); }
		public ITerminalNode Colon() { return GetToken(CommonRegexParser.Colon, 0); }
		public AlternationContext alternation() {
			return GetRuleContext<AlternationContext>(0);
		}
		public ITerminalNode CloseParen() { return GetToken(CommonRegexParser.CloseParen, 0); }
		public Non_captureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_capture; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterNon_capture(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitNon_capture(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNon_capture(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Non_captureContext non_capture() {
		Non_captureContext _localctx = new Non_captureContext(Context, State);
		EnterRule(_localctx, 16, RULE_non_capture);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 139; Match(OpenParen);
			State = 140; Match(QuestionMark);
			State = 141; Match(Colon);
			State = 142; alternation();
			State = 143; Match(CloseParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptionContext : ParserRuleContext {
		public ITerminalNode OpenParen() { return GetToken(CommonRegexParser.OpenParen, 0); }
		public ITerminalNode QuestionMark() { return GetToken(CommonRegexParser.QuestionMark, 0); }
		public ITerminalNode CloseParen() { return GetToken(CommonRegexParser.CloseParen, 0); }
		public Option_flagContext[] option_flag() {
			return GetRuleContexts<Option_flagContext>();
		}
		public Option_flagContext option_flag(int i) {
			return GetRuleContext<Option_flagContext>(i);
		}
		public OptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_option; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterOption(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitOption(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OptionContext option() {
		OptionContext _localctx = new OptionContext(Context, State);
		EnterRule(_localctx, 18, RULE_option);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 145; Match(OpenParen);
			State = 146; Match(QuestionMark);
			State = 148;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 147; option_flag();
				}
				}
				State = 150;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ILC) | (1L << MLC) | (1L << SLC))) != 0) );
			State = 152; Match(CloseParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Option_flagContext : ParserRuleContext {
		public ITerminalNode ILC() { return GetToken(CommonRegexParser.ILC, 0); }
		public ITerminalNode MLC() { return GetToken(CommonRegexParser.MLC, 0); }
		public ITerminalNode SLC() { return GetToken(CommonRegexParser.SLC, 0); }
		public Option_flagContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_option_flag; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterOption_flag(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitOption_flag(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOption_flag(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Option_flagContext option_flag() {
		Option_flagContext _localctx = new Option_flagContext(Context, State);
		EnterRule(_localctx, 20, RULE_option_flag);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 154;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ILC) | (1L << MLC) | (1L << SLC))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AtomContext : ParserRuleContext {
		public Shared_atomContext shared_atom() {
			return GetRuleContext<Shared_atomContext>(0);
		}
		public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public Character_classContext character_class() {
			return GetRuleContext<Character_classContext>(0);
		}
		public CaptureContext capture() {
			return GetRuleContext<CaptureContext>(0);
		}
		public Non_captureContext non_capture() {
			return GetRuleContext<Non_captureContext>(0);
		}
		public OptionContext option() {
			return GetRuleContext<OptionContext>(0);
		}
		public ITerminalNode Dot() { return GetToken(CommonRegexParser.Dot, 0); }
		public ITerminalNode Caret() { return GetToken(CommonRegexParser.Caret, 0); }
		public ITerminalNode EndOfSubject() { return GetToken(CommonRegexParser.EndOfSubject, 0); }
		public AtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_atom; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AtomContext atom() {
		AtomContext _localctx = new AtomContext(Context, State);
		EnterRule(_localctx, 22, RULE_atom);
		try {
			State = 165;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 156; shared_atom();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 157; literal();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 158; character_class();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 159; capture();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 160; non_capture();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 161; option();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 162; Match(Dot);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 163; Match(Caret);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 164; Match(EndOfSubject);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cc_atomContext : ParserRuleContext {
		public Cc_literalContext[] cc_literal() {
			return GetRuleContexts<Cc_literalContext>();
		}
		public Cc_literalContext cc_literal(int i) {
			return GetRuleContext<Cc_literalContext>(i);
		}
		public ITerminalNode Hyphen() { return GetToken(CommonRegexParser.Hyphen, 0); }
		public Shared_atomContext shared_atom() {
			return GetRuleContext<Shared_atomContext>(0);
		}
		public Cc_atomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cc_atom; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterCc_atom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitCc_atom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCc_atom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cc_atomContext cc_atom() {
		Cc_atomContext _localctx = new Cc_atomContext(Context, State);
		EnterRule(_localctx, 24, RULE_cc_atom);
		try {
			State = 173;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 167; cc_literal();
				State = 168; Match(Hyphen);
				State = 169; cc_literal();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 171; shared_atom();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 172; cc_literal();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Shared_atomContext : ParserRuleContext {
		public ITerminalNode ControlChar() { return GetToken(CommonRegexParser.ControlChar, 0); }
		public ITerminalNode DecimalDigit() { return GetToken(CommonRegexParser.DecimalDigit, 0); }
		public ITerminalNode NotDecimalDigit() { return GetToken(CommonRegexParser.NotDecimalDigit, 0); }
		public ITerminalNode CharWithProperty() { return GetToken(CommonRegexParser.CharWithProperty, 0); }
		public ITerminalNode CharWithoutProperty() { return GetToken(CommonRegexParser.CharWithoutProperty, 0); }
		public ITerminalNode WhiteSpace() { return GetToken(CommonRegexParser.WhiteSpace, 0); }
		public ITerminalNode NotWhiteSpace() { return GetToken(CommonRegexParser.NotWhiteSpace, 0); }
		public ITerminalNode WordChar() { return GetToken(CommonRegexParser.WordChar, 0); }
		public ITerminalNode NotWordChar() { return GetToken(CommonRegexParser.NotWordChar, 0); }
		public Shared_atomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shared_atom; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterShared_atom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitShared_atom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShared_atom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Shared_atomContext shared_atom() {
		Shared_atomContext _localctx = new Shared_atomContext(Context, State);
		EnterRule(_localctx, 26, RULE_shared_atom);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 175;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ControlChar) | (1L << DecimalDigit) | (1L << NotDecimalDigit) | (1L << CharWithProperty) | (1L << CharWithoutProperty) | (1L << WhiteSpace) | (1L << NotWhiteSpace) | (1L << WordChar) | (1L << NotWordChar))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		public Shared_literalContext shared_literal() {
			return GetRuleContext<Shared_literalContext>(0);
		}
		public ITerminalNode CharacterClassEnd() { return GetToken(CommonRegexParser.CharacterClassEnd, 0); }
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 28, RULE_literal);
		try {
			State = 179;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Quoted:
			case BlockQuoted:
			case BellChar:
			case EscapeChar:
			case FormFeed:
			case NewLine:
			case CarriageReturn:
			case Tab:
			case Backslash:
			case HexChar:
			case Hyphen:
			case OpenBrace:
			case CloseBrace:
			case Comma:
			case LessThan:
			case GreaterThan:
			case SingleQuote:
			case Underscore:
			case Colon:
			case Hash:
			case Equals:
			case Exclamation:
			case Ampersand:
			case ALC:
			case BLC:
			case CLC:
			case DLC:
			case ELC:
			case FLC:
			case GLC:
			case HLC:
			case ILC:
			case JLC:
			case KLC:
			case LLC:
			case MLC:
			case NLC:
			case OLC:
			case PLC:
			case QLC:
			case RLC:
			case SLC:
			case TLC:
			case ULC:
			case VLC:
			case WLC:
			case XLC:
			case YLC:
			case ZLC:
			case AUC:
			case BUC:
			case CUC:
			case DUC:
			case EUC:
			case FUC:
			case GUC:
			case HUC:
			case IUC:
			case JUC:
			case KUC:
			case LUC:
			case MUC:
			case NUC:
			case OUC:
			case PUC:
			case QUC:
			case RUC:
			case SUC:
			case TUC:
			case UUC:
			case VUC:
			case WUC:
			case XUC:
			case YUC:
			case ZUC:
			case D1:
			case D2:
			case D3:
			case D4:
			case D5:
			case D6:
			case D7:
			case D8:
			case D9:
			case D0:
			case OtherChar:
				EnterOuterAlt(_localctx, 1);
				{
				State = 177; shared_literal();
				}
				break;
			case CharacterClassEnd:
				EnterOuterAlt(_localctx, 2);
				{
				State = 178; Match(CharacterClassEnd);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cc_literalContext : ParserRuleContext {
		public Shared_literalContext shared_literal() {
			return GetRuleContext<Shared_literalContext>(0);
		}
		public ITerminalNode Dot() { return GetToken(CommonRegexParser.Dot, 0); }
		public ITerminalNode CharacterClassStart() { return GetToken(CommonRegexParser.CharacterClassStart, 0); }
		public ITerminalNode Caret() { return GetToken(CommonRegexParser.Caret, 0); }
		public ITerminalNode QuestionMark() { return GetToken(CommonRegexParser.QuestionMark, 0); }
		public ITerminalNode Plus() { return GetToken(CommonRegexParser.Plus, 0); }
		public ITerminalNode Star() { return GetToken(CommonRegexParser.Star, 0); }
		public ITerminalNode EndOfSubject() { return GetToken(CommonRegexParser.EndOfSubject, 0); }
		public ITerminalNode Pipe() { return GetToken(CommonRegexParser.Pipe, 0); }
		public ITerminalNode OpenParen() { return GetToken(CommonRegexParser.OpenParen, 0); }
		public ITerminalNode CloseParen() { return GetToken(CommonRegexParser.CloseParen, 0); }
		public Cc_literalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cc_literal; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterCc_literal(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitCc_literal(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCc_literal(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cc_literalContext cc_literal() {
		Cc_literalContext _localctx = new Cc_literalContext(Context, State);
		EnterRule(_localctx, 30, RULE_cc_literal);
		try {
			State = 192;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Quoted:
			case BlockQuoted:
			case BellChar:
			case EscapeChar:
			case FormFeed:
			case NewLine:
			case CarriageReturn:
			case Tab:
			case Backslash:
			case HexChar:
			case Hyphen:
			case OpenBrace:
			case CloseBrace:
			case Comma:
			case LessThan:
			case GreaterThan:
			case SingleQuote:
			case Underscore:
			case Colon:
			case Hash:
			case Equals:
			case Exclamation:
			case Ampersand:
			case ALC:
			case BLC:
			case CLC:
			case DLC:
			case ELC:
			case FLC:
			case GLC:
			case HLC:
			case ILC:
			case JLC:
			case KLC:
			case LLC:
			case MLC:
			case NLC:
			case OLC:
			case PLC:
			case QLC:
			case RLC:
			case SLC:
			case TLC:
			case ULC:
			case VLC:
			case WLC:
			case XLC:
			case YLC:
			case ZLC:
			case AUC:
			case BUC:
			case CUC:
			case DUC:
			case EUC:
			case FUC:
			case GUC:
			case HUC:
			case IUC:
			case JUC:
			case KUC:
			case LUC:
			case MUC:
			case NUC:
			case OUC:
			case PUC:
			case QUC:
			case RUC:
			case SUC:
			case TUC:
			case UUC:
			case VUC:
			case WUC:
			case XUC:
			case YUC:
			case ZUC:
			case D1:
			case D2:
			case D3:
			case D4:
			case D5:
			case D6:
			case D7:
			case D8:
			case D9:
			case D0:
			case OtherChar:
				EnterOuterAlt(_localctx, 1);
				{
				State = 181; shared_literal();
				}
				break;
			case Dot:
				EnterOuterAlt(_localctx, 2);
				{
				State = 182; Match(Dot);
				}
				break;
			case CharacterClassStart:
				EnterOuterAlt(_localctx, 3);
				{
				State = 183; Match(CharacterClassStart);
				}
				break;
			case Caret:
				EnterOuterAlt(_localctx, 4);
				{
				State = 184; Match(Caret);
				}
				break;
			case QuestionMark:
				EnterOuterAlt(_localctx, 5);
				{
				State = 185; Match(QuestionMark);
				}
				break;
			case Plus:
				EnterOuterAlt(_localctx, 6);
				{
				State = 186; Match(Plus);
				}
				break;
			case Star:
				EnterOuterAlt(_localctx, 7);
				{
				State = 187; Match(Star);
				}
				break;
			case EndOfSubject:
				EnterOuterAlt(_localctx, 8);
				{
				State = 188; Match(EndOfSubject);
				}
				break;
			case Pipe:
				EnterOuterAlt(_localctx, 9);
				{
				State = 189; Match(Pipe);
				}
				break;
			case OpenParen:
				EnterOuterAlt(_localctx, 10);
				{
				State = 190; Match(OpenParen);
				}
				break;
			case CloseParen:
				EnterOuterAlt(_localctx, 11);
				{
				State = 191; Match(CloseParen);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Shared_literalContext : ParserRuleContext {
		public Octal_charContext octal_char() {
			return GetRuleContext<Octal_charContext>(0);
		}
		public LetterContext letter() {
			return GetRuleContext<LetterContext>(0);
		}
		public DigitContext digit() {
			return GetRuleContext<DigitContext>(0);
		}
		public ITerminalNode BellChar() { return GetToken(CommonRegexParser.BellChar, 0); }
		public ITerminalNode EscapeChar() { return GetToken(CommonRegexParser.EscapeChar, 0); }
		public ITerminalNode FormFeed() { return GetToken(CommonRegexParser.FormFeed, 0); }
		public ITerminalNode NewLine() { return GetToken(CommonRegexParser.NewLine, 0); }
		public ITerminalNode CarriageReturn() { return GetToken(CommonRegexParser.CarriageReturn, 0); }
		public ITerminalNode Tab() { return GetToken(CommonRegexParser.Tab, 0); }
		public ITerminalNode HexChar() { return GetToken(CommonRegexParser.HexChar, 0); }
		public ITerminalNode Quoted() { return GetToken(CommonRegexParser.Quoted, 0); }
		public ITerminalNode BlockQuoted() { return GetToken(CommonRegexParser.BlockQuoted, 0); }
		public ITerminalNode OpenBrace() { return GetToken(CommonRegexParser.OpenBrace, 0); }
		public ITerminalNode CloseBrace() { return GetToken(CommonRegexParser.CloseBrace, 0); }
		public ITerminalNode Comma() { return GetToken(CommonRegexParser.Comma, 0); }
		public ITerminalNode Hyphen() { return GetToken(CommonRegexParser.Hyphen, 0); }
		public ITerminalNode LessThan() { return GetToken(CommonRegexParser.LessThan, 0); }
		public ITerminalNode GreaterThan() { return GetToken(CommonRegexParser.GreaterThan, 0); }
		public ITerminalNode SingleQuote() { return GetToken(CommonRegexParser.SingleQuote, 0); }
		public ITerminalNode Underscore() { return GetToken(CommonRegexParser.Underscore, 0); }
		public ITerminalNode Colon() { return GetToken(CommonRegexParser.Colon, 0); }
		public ITerminalNode Hash() { return GetToken(CommonRegexParser.Hash, 0); }
		public ITerminalNode Equals() { return GetToken(CommonRegexParser.Equals, 0); }
		public ITerminalNode Exclamation() { return GetToken(CommonRegexParser.Exclamation, 0); }
		public ITerminalNode Ampersand() { return GetToken(CommonRegexParser.Ampersand, 0); }
		public ITerminalNode OtherChar() { return GetToken(CommonRegexParser.OtherChar, 0); }
		public Shared_literalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shared_literal; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterShared_literal(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitShared_literal(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShared_literal(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Shared_literalContext shared_literal() {
		Shared_literalContext _localctx = new Shared_literalContext(Context, State);
		EnterRule(_localctx, 32, RULE_shared_literal);
		try {
			State = 220;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Backslash:
				EnterOuterAlt(_localctx, 1);
				{
				State = 194; octal_char();
				}
				break;
			case ALC:
			case BLC:
			case CLC:
			case DLC:
			case ELC:
			case FLC:
			case GLC:
			case HLC:
			case ILC:
			case JLC:
			case KLC:
			case LLC:
			case MLC:
			case NLC:
			case OLC:
			case PLC:
			case QLC:
			case RLC:
			case SLC:
			case TLC:
			case ULC:
			case VLC:
			case WLC:
			case XLC:
			case YLC:
			case ZLC:
			case AUC:
			case BUC:
			case CUC:
			case DUC:
			case EUC:
			case FUC:
			case GUC:
			case HUC:
			case IUC:
			case JUC:
			case KUC:
			case LUC:
			case MUC:
			case NUC:
			case OUC:
			case PUC:
			case QUC:
			case RUC:
			case SUC:
			case TUC:
			case UUC:
			case VUC:
			case WUC:
			case XUC:
			case YUC:
			case ZUC:
				EnterOuterAlt(_localctx, 2);
				{
				State = 195; letter();
				}
				break;
			case D1:
			case D2:
			case D3:
			case D4:
			case D5:
			case D6:
			case D7:
			case D8:
			case D9:
			case D0:
				EnterOuterAlt(_localctx, 3);
				{
				State = 196; digit();
				}
				break;
			case BellChar:
				EnterOuterAlt(_localctx, 4);
				{
				State = 197; Match(BellChar);
				}
				break;
			case EscapeChar:
				EnterOuterAlt(_localctx, 5);
				{
				State = 198; Match(EscapeChar);
				}
				break;
			case FormFeed:
				EnterOuterAlt(_localctx, 6);
				{
				State = 199; Match(FormFeed);
				}
				break;
			case NewLine:
				EnterOuterAlt(_localctx, 7);
				{
				State = 200; Match(NewLine);
				}
				break;
			case CarriageReturn:
				EnterOuterAlt(_localctx, 8);
				{
				State = 201; Match(CarriageReturn);
				}
				break;
			case Tab:
				EnterOuterAlt(_localctx, 9);
				{
				State = 202; Match(Tab);
				}
				break;
			case HexChar:
				EnterOuterAlt(_localctx, 10);
				{
				State = 203; Match(HexChar);
				}
				break;
			case Quoted:
				EnterOuterAlt(_localctx, 11);
				{
				State = 204; Match(Quoted);
				}
				break;
			case BlockQuoted:
				EnterOuterAlt(_localctx, 12);
				{
				State = 205; Match(BlockQuoted);
				}
				break;
			case OpenBrace:
				EnterOuterAlt(_localctx, 13);
				{
				State = 206; Match(OpenBrace);
				}
				break;
			case CloseBrace:
				EnterOuterAlt(_localctx, 14);
				{
				State = 207; Match(CloseBrace);
				}
				break;
			case Comma:
				EnterOuterAlt(_localctx, 15);
				{
				State = 208; Match(Comma);
				}
				break;
			case Hyphen:
				EnterOuterAlt(_localctx, 16);
				{
				State = 209; Match(Hyphen);
				}
				break;
			case LessThan:
				EnterOuterAlt(_localctx, 17);
				{
				State = 210; Match(LessThan);
				}
				break;
			case GreaterThan:
				EnterOuterAlt(_localctx, 18);
				{
				State = 211; Match(GreaterThan);
				}
				break;
			case SingleQuote:
				EnterOuterAlt(_localctx, 19);
				{
				State = 212; Match(SingleQuote);
				}
				break;
			case Underscore:
				EnterOuterAlt(_localctx, 20);
				{
				State = 213; Match(Underscore);
				}
				break;
			case Colon:
				EnterOuterAlt(_localctx, 21);
				{
				State = 214; Match(Colon);
				}
				break;
			case Hash:
				EnterOuterAlt(_localctx, 22);
				{
				State = 215; Match(Hash);
				}
				break;
			case Equals:
				EnterOuterAlt(_localctx, 23);
				{
				State = 216; Match(Equals);
				}
				break;
			case Exclamation:
				EnterOuterAlt(_localctx, 24);
				{
				State = 217; Match(Exclamation);
				}
				break;
			case Ampersand:
				EnterOuterAlt(_localctx, 25);
				{
				State = 218; Match(Ampersand);
				}
				break;
			case OtherChar:
				EnterOuterAlt(_localctx, 26);
				{
				State = 219; Match(OtherChar);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberContext : ParserRuleContext {
		public DigitsContext digits() {
			return GetRuleContext<DigitsContext>(0);
		}
		public NumberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_number; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterNumber(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitNumber(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumber(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberContext number() {
		NumberContext _localctx = new NumberContext(Context, State);
		EnterRule(_localctx, 34, RULE_number);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222; digits();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Octal_charContext : ParserRuleContext {
		public ITerminalNode Backslash() { return GetToken(CommonRegexParser.Backslash, 0); }
		public Octal_digitContext[] octal_digit() {
			return GetRuleContexts<Octal_digitContext>();
		}
		public Octal_digitContext octal_digit(int i) {
			return GetRuleContext<Octal_digitContext>(i);
		}
		public ITerminalNode D0() { return GetToken(CommonRegexParser.D0, 0); }
		public ITerminalNode D1() { return GetToken(CommonRegexParser.D1, 0); }
		public ITerminalNode D2() { return GetToken(CommonRegexParser.D2, 0); }
		public ITerminalNode D3() { return GetToken(CommonRegexParser.D3, 0); }
		public Octal_charContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_octal_char; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterOctal_char(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitOctal_char(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOctal_char(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Octal_charContext octal_char() {
		Octal_charContext _localctx = new Octal_charContext(Context, State);
		EnterRule(_localctx, 36, RULE_octal_char);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 233;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				{
				State = 224; Match(Backslash);
				State = 225;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 96)) & ~0x3f) == 0 && ((1L << (_la - 96)) & ((1L << (D1 - 96)) | (1L << (D2 - 96)) | (1L << (D3 - 96)) | (1L << (D0 - 96)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 226; octal_digit();
				State = 227; octal_digit();
				}
				break;
			case 2:
				{
				State = 229; Match(Backslash);
				State = 230; octal_digit();
				State = 231; octal_digit();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Octal_digitContext : ParserRuleContext {
		public ITerminalNode D0() { return GetToken(CommonRegexParser.D0, 0); }
		public ITerminalNode D1() { return GetToken(CommonRegexParser.D1, 0); }
		public ITerminalNode D2() { return GetToken(CommonRegexParser.D2, 0); }
		public ITerminalNode D3() { return GetToken(CommonRegexParser.D3, 0); }
		public ITerminalNode D4() { return GetToken(CommonRegexParser.D4, 0); }
		public ITerminalNode D5() { return GetToken(CommonRegexParser.D5, 0); }
		public ITerminalNode D6() { return GetToken(CommonRegexParser.D6, 0); }
		public ITerminalNode D7() { return GetToken(CommonRegexParser.D7, 0); }
		public Octal_digitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_octal_digit; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterOctal_digit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitOctal_digit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOctal_digit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Octal_digitContext octal_digit() {
		Octal_digitContext _localctx = new Octal_digitContext(Context, State);
		EnterRule(_localctx, 38, RULE_octal_digit);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 235;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 96)) & ~0x3f) == 0 && ((1L << (_la - 96)) & ((1L << (D1 - 96)) | (1L << (D2 - 96)) | (1L << (D3 - 96)) | (1L << (D4 - 96)) | (1L << (D5 - 96)) | (1L << (D6 - 96)) | (1L << (D7 - 96)) | (1L << (D0 - 96)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DigitsContext : ParserRuleContext {
		public DigitContext[] digit() {
			return GetRuleContexts<DigitContext>();
		}
		public DigitContext digit(int i) {
			return GetRuleContext<DigitContext>(i);
		}
		public DigitsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_digits; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterDigits(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitDigits(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDigits(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DigitsContext digits() {
		DigitsContext _localctx = new DigitsContext(Context, State);
		EnterRule(_localctx, 40, RULE_digits);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 238;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 237; digit();
				}
				}
				State = 240;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( ((((_la - 96)) & ~0x3f) == 0 && ((1L << (_la - 96)) & ((1L << (D1 - 96)) | (1L << (D2 - 96)) | (1L << (D3 - 96)) | (1L << (D4 - 96)) | (1L << (D5 - 96)) | (1L << (D6 - 96)) | (1L << (D7 - 96)) | (1L << (D8 - 96)) | (1L << (D9 - 96)) | (1L << (D0 - 96)))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DigitContext : ParserRuleContext {
		public ITerminalNode D0() { return GetToken(CommonRegexParser.D0, 0); }
		public ITerminalNode D1() { return GetToken(CommonRegexParser.D1, 0); }
		public ITerminalNode D2() { return GetToken(CommonRegexParser.D2, 0); }
		public ITerminalNode D3() { return GetToken(CommonRegexParser.D3, 0); }
		public ITerminalNode D4() { return GetToken(CommonRegexParser.D4, 0); }
		public ITerminalNode D5() { return GetToken(CommonRegexParser.D5, 0); }
		public ITerminalNode D6() { return GetToken(CommonRegexParser.D6, 0); }
		public ITerminalNode D7() { return GetToken(CommonRegexParser.D7, 0); }
		public ITerminalNode D8() { return GetToken(CommonRegexParser.D8, 0); }
		public ITerminalNode D9() { return GetToken(CommonRegexParser.D9, 0); }
		public DigitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_digit; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterDigit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitDigit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDigit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DigitContext digit() {
		DigitContext _localctx = new DigitContext(Context, State);
		EnterRule(_localctx, 42, RULE_digit);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 242;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 96)) & ~0x3f) == 0 && ((1L << (_la - 96)) & ((1L << (D1 - 96)) | (1L << (D2 - 96)) | (1L << (D3 - 96)) | (1L << (D4 - 96)) | (1L << (D5 - 96)) | (1L << (D6 - 96)) | (1L << (D7 - 96)) | (1L << (D8 - 96)) | (1L << (D9 - 96)) | (1L << (D0 - 96)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NameContext : ParserRuleContext {
		public Alpha_numsContext alpha_nums() {
			return GetRuleContext<Alpha_numsContext>(0);
		}
		public NameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NameContext name() {
		NameContext _localctx = new NameContext(Context, State);
		EnterRule(_localctx, 44, RULE_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 244; alpha_nums();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alpha_numsContext : ParserRuleContext {
		public LetterContext[] letter() {
			return GetRuleContexts<LetterContext>();
		}
		public LetterContext letter(int i) {
			return GetRuleContext<LetterContext>(i);
		}
		public ITerminalNode[] Underscore() { return GetTokens(CommonRegexParser.Underscore); }
		public ITerminalNode Underscore(int i) {
			return GetToken(CommonRegexParser.Underscore, i);
		}
		public DigitContext[] digit() {
			return GetRuleContexts<DigitContext>();
		}
		public DigitContext digit(int i) {
			return GetRuleContext<DigitContext>(i);
		}
		public Alpha_numsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alpha_nums; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterAlpha_nums(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitAlpha_nums(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlpha_nums(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alpha_numsContext alpha_nums() {
		Alpha_numsContext _localctx = new Alpha_numsContext(Context, State);
		EnterRule(_localctx, 46, RULE_alpha_nums);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 248;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALC:
			case BLC:
			case CLC:
			case DLC:
			case ELC:
			case FLC:
			case GLC:
			case HLC:
			case ILC:
			case JLC:
			case KLC:
			case LLC:
			case MLC:
			case NLC:
			case OLC:
			case PLC:
			case QLC:
			case RLC:
			case SLC:
			case TLC:
			case ULC:
			case VLC:
			case WLC:
			case XLC:
			case YLC:
			case ZLC:
			case AUC:
			case BUC:
			case CUC:
			case DUC:
			case EUC:
			case FUC:
			case GUC:
			case HUC:
			case IUC:
			case JUC:
			case KUC:
			case LUC:
			case MUC:
			case NUC:
			case OUC:
			case PUC:
			case QUC:
			case RUC:
			case SUC:
			case TUC:
			case UUC:
			case VUC:
			case WUC:
			case XUC:
			case YUC:
			case ZUC:
				{
				State = 246; letter();
				}
				break;
			case Underscore:
				{
				State = 247; Match(Underscore);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 255;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Underscore) | (1L << ALC) | (1L << BLC) | (1L << CLC) | (1L << DLC) | (1L << ELC) | (1L << FLC) | (1L << GLC) | (1L << HLC) | (1L << ILC) | (1L << JLC) | (1L << KLC) | (1L << LLC) | (1L << MLC) | (1L << NLC) | (1L << OLC) | (1L << PLC) | (1L << QLC) | (1L << RLC) | (1L << SLC) | (1L << TLC))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (ULC - 64)) | (1L << (VLC - 64)) | (1L << (WLC - 64)) | (1L << (XLC - 64)) | (1L << (YLC - 64)) | (1L << (ZLC - 64)) | (1L << (AUC - 64)) | (1L << (BUC - 64)) | (1L << (CUC - 64)) | (1L << (DUC - 64)) | (1L << (EUC - 64)) | (1L << (FUC - 64)) | (1L << (GUC - 64)) | (1L << (HUC - 64)) | (1L << (IUC - 64)) | (1L << (JUC - 64)) | (1L << (KUC - 64)) | (1L << (LUC - 64)) | (1L << (MUC - 64)) | (1L << (NUC - 64)) | (1L << (OUC - 64)) | (1L << (PUC - 64)) | (1L << (QUC - 64)) | (1L << (RUC - 64)) | (1L << (SUC - 64)) | (1L << (TUC - 64)) | (1L << (UUC - 64)) | (1L << (VUC - 64)) | (1L << (WUC - 64)) | (1L << (XUC - 64)) | (1L << (YUC - 64)) | (1L << (ZUC - 64)) | (1L << (D1 - 64)) | (1L << (D2 - 64)) | (1L << (D3 - 64)) | (1L << (D4 - 64)) | (1L << (D5 - 64)) | (1L << (D6 - 64)) | (1L << (D7 - 64)) | (1L << (D8 - 64)) | (1L << (D9 - 64)) | (1L << (D0 - 64)))) != 0)) {
				{
				State = 253;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ALC:
				case BLC:
				case CLC:
				case DLC:
				case ELC:
				case FLC:
				case GLC:
				case HLC:
				case ILC:
				case JLC:
				case KLC:
				case LLC:
				case MLC:
				case NLC:
				case OLC:
				case PLC:
				case QLC:
				case RLC:
				case SLC:
				case TLC:
				case ULC:
				case VLC:
				case WLC:
				case XLC:
				case YLC:
				case ZLC:
				case AUC:
				case BUC:
				case CUC:
				case DUC:
				case EUC:
				case FUC:
				case GUC:
				case HUC:
				case IUC:
				case JUC:
				case KUC:
				case LUC:
				case MUC:
				case NUC:
				case OUC:
				case PUC:
				case QUC:
				case RUC:
				case SUC:
				case TUC:
				case UUC:
				case VUC:
				case WUC:
				case XUC:
				case YUC:
				case ZUC:
					{
					State = 250; letter();
					}
					break;
				case Underscore:
					{
					State = 251; Match(Underscore);
					}
					break;
				case D1:
				case D2:
				case D3:
				case D4:
				case D5:
				case D6:
				case D7:
				case D8:
				case D9:
				case D0:
					{
					State = 252; digit();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 257;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_close_parensContext : ParserRuleContext {
		public Non_close_parenContext[] non_close_paren() {
			return GetRuleContexts<Non_close_parenContext>();
		}
		public Non_close_parenContext non_close_paren(int i) {
			return GetRuleContext<Non_close_parenContext>(i);
		}
		public Non_close_parensContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_close_parens; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterNon_close_parens(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitNon_close_parens(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNon_close_parens(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Non_close_parensContext non_close_parens() {
		Non_close_parensContext _localctx = new Non_close_parensContext(Context, State);
		EnterRule(_localctx, 48, RULE_non_close_parens);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 258; non_close_paren();
				}
				}
				State = 261;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Quoted) | (1L << BlockQuoted) | (1L << BellChar) | (1L << ControlChar) | (1L << EscapeChar) | (1L << FormFeed) | (1L << NewLine) | (1L << CarriageReturn) | (1L << Tab) | (1L << Backslash) | (1L << HexChar) | (1L << Dot) | (1L << DecimalDigit) | (1L << NotDecimalDigit) | (1L << CharWithProperty) | (1L << CharWithoutProperty) | (1L << WhiteSpace) | (1L << NotWhiteSpace) | (1L << WordChar) | (1L << NotWordChar) | (1L << CharacterClassStart) | (1L << CharacterClassEnd) | (1L << Caret) | (1L << Hyphen) | (1L << QuestionMark) | (1L << Plus) | (1L << Star) | (1L << OpenBrace) | (1L << CloseBrace) | (1L << Comma) | (1L << EndOfSubject) | (1L << Pipe) | (1L << OpenParen) | (1L << LessThan) | (1L << GreaterThan) | (1L << SingleQuote) | (1L << Underscore) | (1L << Colon) | (1L << Hash) | (1L << Equals) | (1L << Exclamation) | (1L << Ampersand) | (1L << ALC) | (1L << BLC) | (1L << CLC) | (1L << DLC) | (1L << ELC) | (1L << FLC) | (1L << GLC) | (1L << HLC) | (1L << ILC) | (1L << JLC) | (1L << KLC) | (1L << LLC) | (1L << MLC) | (1L << NLC) | (1L << OLC) | (1L << PLC) | (1L << QLC) | (1L << RLC) | (1L << SLC) | (1L << TLC))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (ULC - 64)) | (1L << (VLC - 64)) | (1L << (WLC - 64)) | (1L << (XLC - 64)) | (1L << (YLC - 64)) | (1L << (ZLC - 64)) | (1L << (AUC - 64)) | (1L << (BUC - 64)) | (1L << (CUC - 64)) | (1L << (DUC - 64)) | (1L << (EUC - 64)) | (1L << (FUC - 64)) | (1L << (GUC - 64)) | (1L << (HUC - 64)) | (1L << (IUC - 64)) | (1L << (JUC - 64)) | (1L << (KUC - 64)) | (1L << (LUC - 64)) | (1L << (MUC - 64)) | (1L << (NUC - 64)) | (1L << (OUC - 64)) | (1L << (PUC - 64)) | (1L << (QUC - 64)) | (1L << (RUC - 64)) | (1L << (SUC - 64)) | (1L << (TUC - 64)) | (1L << (UUC - 64)) | (1L << (VUC - 64)) | (1L << (WUC - 64)) | (1L << (XUC - 64)) | (1L << (YUC - 64)) | (1L << (ZUC - 64)) | (1L << (D1 - 64)) | (1L << (D2 - 64)) | (1L << (D3 - 64)) | (1L << (D4 - 64)) | (1L << (D5 - 64)) | (1L << (D6 - 64)) | (1L << (D7 - 64)) | (1L << (D8 - 64)) | (1L << (D9 - 64)) | (1L << (D0 - 64)) | (1L << (OtherChar - 64)))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_close_parenContext : ParserRuleContext {
		public ITerminalNode CloseParen() { return GetToken(CommonRegexParser.CloseParen, 0); }
		public Non_close_parenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_close_paren; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterNon_close_paren(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitNon_close_paren(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNon_close_paren(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Non_close_parenContext non_close_paren() {
		Non_close_parenContext _localctx = new Non_close_parenContext(Context, State);
		EnterRule(_localctx, 50, RULE_non_close_paren);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 263;
			_la = TokenStream.LA(1);
			if ( _la <= 0 || (_la==CloseParen) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LetterContext : ParserRuleContext {
		public ITerminalNode ALC() { return GetToken(CommonRegexParser.ALC, 0); }
		public ITerminalNode BLC() { return GetToken(CommonRegexParser.BLC, 0); }
		public ITerminalNode CLC() { return GetToken(CommonRegexParser.CLC, 0); }
		public ITerminalNode DLC() { return GetToken(CommonRegexParser.DLC, 0); }
		public ITerminalNode ELC() { return GetToken(CommonRegexParser.ELC, 0); }
		public ITerminalNode FLC() { return GetToken(CommonRegexParser.FLC, 0); }
		public ITerminalNode GLC() { return GetToken(CommonRegexParser.GLC, 0); }
		public ITerminalNode HLC() { return GetToken(CommonRegexParser.HLC, 0); }
		public ITerminalNode ILC() { return GetToken(CommonRegexParser.ILC, 0); }
		public ITerminalNode JLC() { return GetToken(CommonRegexParser.JLC, 0); }
		public ITerminalNode KLC() { return GetToken(CommonRegexParser.KLC, 0); }
		public ITerminalNode LLC() { return GetToken(CommonRegexParser.LLC, 0); }
		public ITerminalNode MLC() { return GetToken(CommonRegexParser.MLC, 0); }
		public ITerminalNode NLC() { return GetToken(CommonRegexParser.NLC, 0); }
		public ITerminalNode OLC() { return GetToken(CommonRegexParser.OLC, 0); }
		public ITerminalNode PLC() { return GetToken(CommonRegexParser.PLC, 0); }
		public ITerminalNode QLC() { return GetToken(CommonRegexParser.QLC, 0); }
		public ITerminalNode RLC() { return GetToken(CommonRegexParser.RLC, 0); }
		public ITerminalNode SLC() { return GetToken(CommonRegexParser.SLC, 0); }
		public ITerminalNode TLC() { return GetToken(CommonRegexParser.TLC, 0); }
		public ITerminalNode ULC() { return GetToken(CommonRegexParser.ULC, 0); }
		public ITerminalNode VLC() { return GetToken(CommonRegexParser.VLC, 0); }
		public ITerminalNode WLC() { return GetToken(CommonRegexParser.WLC, 0); }
		public ITerminalNode XLC() { return GetToken(CommonRegexParser.XLC, 0); }
		public ITerminalNode YLC() { return GetToken(CommonRegexParser.YLC, 0); }
		public ITerminalNode ZLC() { return GetToken(CommonRegexParser.ZLC, 0); }
		public ITerminalNode AUC() { return GetToken(CommonRegexParser.AUC, 0); }
		public ITerminalNode BUC() { return GetToken(CommonRegexParser.BUC, 0); }
		public ITerminalNode CUC() { return GetToken(CommonRegexParser.CUC, 0); }
		public ITerminalNode DUC() { return GetToken(CommonRegexParser.DUC, 0); }
		public ITerminalNode EUC() { return GetToken(CommonRegexParser.EUC, 0); }
		public ITerminalNode FUC() { return GetToken(CommonRegexParser.FUC, 0); }
		public ITerminalNode GUC() { return GetToken(CommonRegexParser.GUC, 0); }
		public ITerminalNode HUC() { return GetToken(CommonRegexParser.HUC, 0); }
		public ITerminalNode IUC() { return GetToken(CommonRegexParser.IUC, 0); }
		public ITerminalNode JUC() { return GetToken(CommonRegexParser.JUC, 0); }
		public ITerminalNode KUC() { return GetToken(CommonRegexParser.KUC, 0); }
		public ITerminalNode LUC() { return GetToken(CommonRegexParser.LUC, 0); }
		public ITerminalNode MUC() { return GetToken(CommonRegexParser.MUC, 0); }
		public ITerminalNode NUC() { return GetToken(CommonRegexParser.NUC, 0); }
		public ITerminalNode OUC() { return GetToken(CommonRegexParser.OUC, 0); }
		public ITerminalNode PUC() { return GetToken(CommonRegexParser.PUC, 0); }
		public ITerminalNode QUC() { return GetToken(CommonRegexParser.QUC, 0); }
		public ITerminalNode RUC() { return GetToken(CommonRegexParser.RUC, 0); }
		public ITerminalNode SUC() { return GetToken(CommonRegexParser.SUC, 0); }
		public ITerminalNode TUC() { return GetToken(CommonRegexParser.TUC, 0); }
		public ITerminalNode UUC() { return GetToken(CommonRegexParser.UUC, 0); }
		public ITerminalNode VUC() { return GetToken(CommonRegexParser.VUC, 0); }
		public ITerminalNode WUC() { return GetToken(CommonRegexParser.WUC, 0); }
		public ITerminalNode XUC() { return GetToken(CommonRegexParser.XUC, 0); }
		public ITerminalNode YUC() { return GetToken(CommonRegexParser.YUC, 0); }
		public ITerminalNode ZUC() { return GetToken(CommonRegexParser.ZUC, 0); }
		public LetterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_letter; } }
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterLetter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitLetter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLetter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LetterContext letter() {
		LetterContext _localctx = new LetterContext(Context, State);
		EnterRule(_localctx, 52, RULE_letter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 265;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 44)) & ~0x3f) == 0 && ((1L << (_la - 44)) & ((1L << (ALC - 44)) | (1L << (BLC - 44)) | (1L << (CLC - 44)) | (1L << (DLC - 44)) | (1L << (ELC - 44)) | (1L << (FLC - 44)) | (1L << (GLC - 44)) | (1L << (HLC - 44)) | (1L << (ILC - 44)) | (1L << (JLC - 44)) | (1L << (KLC - 44)) | (1L << (LLC - 44)) | (1L << (MLC - 44)) | (1L << (NLC - 44)) | (1L << (OLC - 44)) | (1L << (PLC - 44)) | (1L << (QLC - 44)) | (1L << (RLC - 44)) | (1L << (SLC - 44)) | (1L << (TLC - 44)) | (1L << (ULC - 44)) | (1L << (VLC - 44)) | (1L << (WLC - 44)) | (1L << (XLC - 44)) | (1L << (YLC - 44)) | (1L << (ZLC - 44)) | (1L << (AUC - 44)) | (1L << (BUC - 44)) | (1L << (CUC - 44)) | (1L << (DUC - 44)) | (1L << (EUC - 44)) | (1L << (FUC - 44)) | (1L << (GUC - 44)) | (1L << (HUC - 44)) | (1L << (IUC - 44)) | (1L << (JUC - 44)) | (1L << (KUC - 44)) | (1L << (LUC - 44)) | (1L << (MUC - 44)) | (1L << (NUC - 44)) | (1L << (OUC - 44)) | (1L << (PUC - 44)) | (1L << (QUC - 44)) | (1L << (RUC - 44)) | (1L << (SUC - 44)) | (1L << (TUC - 44)) | (1L << (UUC - 44)) | (1L << (VUC - 44)) | (1L << (WUC - 44)) | (1L << (XUC - 44)) | (1L << (YUC - 44)) | (1L << (ZUC - 44)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', 'l', '\x10E', '\x4', '\x2', '\t', '\x2', '\x4', '\x3', 
		'\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4', 
		'\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b', 
		'\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v', 
		'\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', '\t', 
		'\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4', 
		'\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t', 
		'\x13', '\x4', '\x14', '\t', '\x14', '\x4', '\x15', '\t', '\x15', '\x4', 
		'\x16', '\t', '\x16', '\x4', '\x17', '\t', '\x17', '\x4', '\x18', '\t', 
		'\x18', '\x4', '\x19', '\t', '\x19', '\x4', '\x1A', '\t', '\x1A', '\x4', 
		'\x1B', '\t', '\x1B', '\x4', '\x1C', '\t', '\x1C', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\a', '\x3', 
		'?', '\n', '\x3', '\f', '\x3', '\xE', '\x3', '\x42', '\v', '\x3', '\x3', 
		'\x4', '\a', '\x4', '\x45', '\n', '\x4', '\f', '\x4', '\xE', '\x4', 'H', 
		'\v', '\x4', '\x3', '\x5', '\x3', '\x5', '\x5', '\x5', 'L', '\n', '\x5', 
		'\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', 
		'\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', 
		'\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', 
		'\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', 
		'\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x5', '\x6', 
		'\x66', '\n', '\x6', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x5', '\a', 
		'k', '\n', '\a', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x6', '\b', 'p', 
		'\n', '\b', '\r', '\b', '\xE', '\b', 'q', '\x3', '\b', '\x3', '\b', '\x3', 
		'\b', '\x3', '\b', '\x6', '\b', 'x', '\n', '\b', '\r', '\b', '\xE', '\b', 
		'y', '\x3', '\b', '\x3', '\b', '\x5', '\b', '~', '\n', '\b', '\x3', '\t', 
		'\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', 
		'\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', 
		'\x5', '\t', '\x8C', '\n', '\t', '\x3', '\n', '\x3', '\n', '\x3', '\n', 
		'\x3', '\n', '\x3', '\n', '\x3', '\n', '\x3', '\v', '\x3', '\v', '\x3', 
		'\v', '\x6', '\v', '\x97', '\n', '\v', '\r', '\v', '\xE', '\v', '\x98', 
		'\x3', '\v', '\x3', '\v', '\x3', '\f', '\x3', '\f', '\x3', '\r', '\x3', 
		'\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', 
		'\x3', '\r', '\x3', '\r', '\x5', '\r', '\xA8', '\n', '\r', '\x3', '\xE', 
		'\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', 
		'\x5', '\xE', '\xB0', '\n', '\xE', '\x3', '\xF', '\x3', '\xF', '\x3', 
		'\x10', '\x3', '\x10', '\x5', '\x10', '\xB6', '\n', '\x10', '\x3', '\x11', 
		'\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', 
		'\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', 
		'\x5', '\x11', '\xC3', '\n', '\x11', '\x3', '\x12', '\x3', '\x12', '\x3', 
		'\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', 
		'\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', 
		'\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', 
		'\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', 
		'\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x5', '\x12', '\xDF', 
		'\n', '\x12', '\x3', '\x13', '\x3', '\x13', '\x3', '\x14', '\x3', '\x14', 
		'\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', 
		'\x3', '\x14', '\x3', '\x14', '\x5', '\x14', '\xEC', '\n', '\x14', '\x3', 
		'\x15', '\x3', '\x15', '\x3', '\x16', '\x6', '\x16', '\xF1', '\n', '\x16', 
		'\r', '\x16', '\xE', '\x16', '\xF2', '\x3', '\x17', '\x3', '\x17', '\x3', 
		'\x18', '\x3', '\x18', '\x3', '\x19', '\x3', '\x19', '\x5', '\x19', '\xFB', 
		'\n', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\a', '\x19', 
		'\x100', '\n', '\x19', '\f', '\x19', '\xE', '\x19', '\x103', '\v', '\x19', 
		'\x3', '\x1A', '\x6', '\x1A', '\x106', '\n', '\x1A', '\r', '\x1A', '\xE', 
		'\x1A', '\x107', '\x3', '\x1B', '\x3', '\x1B', '\x3', '\x1C', '\x3', '\x1C', 
		'\x3', '\x1C', '\x2', '\x2', '\x1D', '\x2', '\x4', '\x6', '\b', '\n', 
		'\f', '\xE', '\x10', '\x12', '\x14', '\x16', '\x18', '\x1A', '\x1C', '\x1E', 
		' ', '\"', '$', '&', '(', '*', ',', '.', '\x30', '\x32', '\x34', '\x36', 
		'\x2', '\t', '\x5', '\x2', '\x36', '\x36', ':', ':', '@', '@', '\x4', 
		'\x2', '\x6', '\x6', '\xF', '\x16', '\x4', '\x2', '\x62', '\x64', 'k', 
		'k', '\x4', '\x2', '\x62', 'h', 'k', 'k', '\x3', '\x2', '\x62', 'k', '\x3', 
		'\x2', '$', '$', '\x3', '\x2', '.', '\x61', '\x2', '\x136', '\x2', '\x38', 
		'\x3', '\x2', '\x2', '\x2', '\x4', ';', '\x3', '\x2', '\x2', '\x2', '\x6', 
		'\x46', '\x3', '\x2', '\x2', '\x2', '\b', 'I', '\x3', '\x2', '\x2', '\x2', 
		'\n', '\x65', '\x3', '\x2', '\x2', '\x2', '\f', 'j', '\x3', '\x2', '\x2', 
		'\x2', '\xE', '}', '\x3', '\x2', '\x2', '\x2', '\x10', '\x8B', '\x3', 
		'\x2', '\x2', '\x2', '\x12', '\x8D', '\x3', '\x2', '\x2', '\x2', '\x14', 
		'\x93', '\x3', '\x2', '\x2', '\x2', '\x16', '\x9C', '\x3', '\x2', '\x2', 
		'\x2', '\x18', '\xA7', '\x3', '\x2', '\x2', '\x2', '\x1A', '\xAF', '\x3', 
		'\x2', '\x2', '\x2', '\x1C', '\xB1', '\x3', '\x2', '\x2', '\x2', '\x1E', 
		'\xB5', '\x3', '\x2', '\x2', '\x2', ' ', '\xC2', '\x3', '\x2', '\x2', 
		'\x2', '\"', '\xDE', '\x3', '\x2', '\x2', '\x2', '$', '\xE0', '\x3', '\x2', 
		'\x2', '\x2', '&', '\xEB', '\x3', '\x2', '\x2', '\x2', '(', '\xED', '\x3', 
		'\x2', '\x2', '\x2', '*', '\xF0', '\x3', '\x2', '\x2', '\x2', ',', '\xF4', 
		'\x3', '\x2', '\x2', '\x2', '.', '\xF6', '\x3', '\x2', '\x2', '\x2', '\x30', 
		'\xFA', '\x3', '\x2', '\x2', '\x2', '\x32', '\x105', '\x3', '\x2', '\x2', 
		'\x2', '\x34', '\x109', '\x3', '\x2', '\x2', '\x2', '\x36', '\x10B', '\x3', 
		'\x2', '\x2', '\x2', '\x38', '\x39', '\x5', '\x4', '\x3', '\x2', '\x39', 
		':', '\a', '\x2', '\x2', '\x3', ':', '\x3', '\x3', '\x2', '\x2', '\x2', 
		';', '@', '\x5', '\x6', '\x4', '\x2', '<', '=', '\a', '\"', '\x2', '\x2', 
		'=', '?', '\x5', '\x6', '\x4', '\x2', '>', '<', '\x3', '\x2', '\x2', '\x2', 
		'?', '\x42', '\x3', '\x2', '\x2', '\x2', '@', '>', '\x3', '\x2', '\x2', 
		'\x2', '@', '\x41', '\x3', '\x2', '\x2', '\x2', '\x41', '\x5', '\x3', 
		'\x2', '\x2', '\x2', '\x42', '@', '\x3', '\x2', '\x2', '\x2', '\x43', 
		'\x45', '\x5', '\b', '\x5', '\x2', '\x44', '\x43', '\x3', '\x2', '\x2', 
		'\x2', '\x45', 'H', '\x3', '\x2', '\x2', '\x2', '\x46', '\x44', '\x3', 
		'\x2', '\x2', '\x2', '\x46', 'G', '\x3', '\x2', '\x2', '\x2', 'G', '\a', 
		'\x3', '\x2', '\x2', '\x2', 'H', '\x46', '\x3', '\x2', '\x2', '\x2', 'I', 
		'K', '\x5', '\x18', '\r', '\x2', 'J', 'L', '\x5', '\n', '\x6', '\x2', 
		'K', 'J', '\x3', '\x2', '\x2', '\x2', 'K', 'L', '\x3', '\x2', '\x2', '\x2', 
		'L', '\t', '\x3', '\x2', '\x2', '\x2', 'M', 'N', '\a', '\x1B', '\x2', 
		'\x2', 'N', '\x66', '\x5', '\f', '\a', '\x2', 'O', 'P', '\a', '\x1C', 
		'\x2', '\x2', 'P', '\x66', '\x5', '\f', '\a', '\x2', 'Q', 'R', '\a', '\x1D', 
		'\x2', '\x2', 'R', '\x66', '\x5', '\f', '\a', '\x2', 'S', 'T', '\a', '\x1E', 
		'\x2', '\x2', 'T', 'U', '\x5', '$', '\x13', '\x2', 'U', 'V', '\a', '\x1F', 
		'\x2', '\x2', 'V', 'W', '\x5', '\f', '\a', '\x2', 'W', '\x66', '\x3', 
		'\x2', '\x2', '\x2', 'X', 'Y', '\a', '\x1E', '\x2', '\x2', 'Y', 'Z', '\x5', 
		'$', '\x13', '\x2', 'Z', '[', '\a', ' ', '\x2', '\x2', '[', '\\', '\a', 
		'\x1F', '\x2', '\x2', '\\', ']', '\x5', '\f', '\a', '\x2', ']', '\x66', 
		'\x3', '\x2', '\x2', '\x2', '^', '_', '\a', '\x1E', '\x2', '\x2', '_', 
		'`', '\x5', '$', '\x13', '\x2', '`', '\x61', '\a', ' ', '\x2', '\x2', 
		'\x61', '\x62', '\x5', '$', '\x13', '\x2', '\x62', '\x63', '\a', '\x1F', 
		'\x2', '\x2', '\x63', '\x64', '\x5', '\f', '\a', '\x2', '\x64', '\x66', 
		'\x3', '\x2', '\x2', '\x2', '\x65', 'M', '\x3', '\x2', '\x2', '\x2', '\x65', 
		'O', '\x3', '\x2', '\x2', '\x2', '\x65', 'Q', '\x3', '\x2', '\x2', '\x2', 
		'\x65', 'S', '\x3', '\x2', '\x2', '\x2', '\x65', 'X', '\x3', '\x2', '\x2', 
		'\x2', '\x65', '^', '\x3', '\x2', '\x2', '\x2', '\x66', '\v', '\x3', '\x2', 
		'\x2', '\x2', 'g', 'k', '\a', '\x1C', '\x2', '\x2', 'h', 'k', '\a', '\x1B', 
		'\x2', '\x2', 'i', 'k', '\x3', '\x2', '\x2', '\x2', 'j', 'g', '\x3', '\x2', 
		'\x2', '\x2', 'j', 'h', '\x3', '\x2', '\x2', '\x2', 'j', 'i', '\x3', '\x2', 
		'\x2', '\x2', 'k', '\r', '\x3', '\x2', '\x2', '\x2', 'l', 'm', '\a', '\x17', 
		'\x2', '\x2', 'm', 'o', '\a', '\x19', '\x2', '\x2', 'n', 'p', '\x5', '\x1A', 
		'\xE', '\x2', 'o', 'n', '\x3', '\x2', '\x2', '\x2', 'p', 'q', '\x3', '\x2', 
		'\x2', '\x2', 'q', 'o', '\x3', '\x2', '\x2', '\x2', 'q', 'r', '\x3', '\x2', 
		'\x2', '\x2', 'r', 's', '\x3', '\x2', '\x2', '\x2', 's', 't', '\a', '\x18', 
		'\x2', '\x2', 't', '~', '\x3', '\x2', '\x2', '\x2', 'u', 'w', '\a', '\x17', 
		'\x2', '\x2', 'v', 'x', '\x5', '\x1A', '\xE', '\x2', 'w', 'v', '\x3', 
		'\x2', '\x2', '\x2', 'x', 'y', '\x3', '\x2', '\x2', '\x2', 'y', 'w', '\x3', 
		'\x2', '\x2', '\x2', 'y', 'z', '\x3', '\x2', '\x2', '\x2', 'z', '{', '\x3', 
		'\x2', '\x2', '\x2', '{', '|', '\a', '\x18', '\x2', '\x2', '|', '~', '\x3', 
		'\x2', '\x2', '\x2', '}', 'l', '\x3', '\x2', '\x2', '\x2', '}', 'u', '\x3', 
		'\x2', '\x2', '\x2', '~', '\xF', '\x3', '\x2', '\x2', '\x2', '\x7F', '\x80', 
		'\a', '#', '\x2', '\x2', '\x80', '\x81', '\a', '\x1B', '\x2', '\x2', '\x81', 
		'\x82', '\a', '%', '\x2', '\x2', '\x82', '\x83', '\x5', '.', '\x18', '\x2', 
		'\x83', '\x84', '\a', '&', '\x2', '\x2', '\x84', '\x85', '\x5', '\x4', 
		'\x3', '\x2', '\x85', '\x86', '\a', '$', '\x2', '\x2', '\x86', '\x8C', 
		'\x3', '\x2', '\x2', '\x2', '\x87', '\x88', '\a', '#', '\x2', '\x2', '\x88', 
		'\x89', '\x5', '\x4', '\x3', '\x2', '\x89', '\x8A', '\a', '$', '\x2', 
		'\x2', '\x8A', '\x8C', '\x3', '\x2', '\x2', '\x2', '\x8B', '\x7F', '\x3', 
		'\x2', '\x2', '\x2', '\x8B', '\x87', '\x3', '\x2', '\x2', '\x2', '\x8C', 
		'\x11', '\x3', '\x2', '\x2', '\x2', '\x8D', '\x8E', '\a', '#', '\x2', 
		'\x2', '\x8E', '\x8F', '\a', '\x1B', '\x2', '\x2', '\x8F', '\x90', '\a', 
		')', '\x2', '\x2', '\x90', '\x91', '\x5', '\x4', '\x3', '\x2', '\x91', 
		'\x92', '\a', '$', '\x2', '\x2', '\x92', '\x13', '\x3', '\x2', '\x2', 
		'\x2', '\x93', '\x94', '\a', '#', '\x2', '\x2', '\x94', '\x96', '\a', 
		'\x1B', '\x2', '\x2', '\x95', '\x97', '\x5', '\x16', '\f', '\x2', '\x96', 
		'\x95', '\x3', '\x2', '\x2', '\x2', '\x97', '\x98', '\x3', '\x2', '\x2', 
		'\x2', '\x98', '\x96', '\x3', '\x2', '\x2', '\x2', '\x98', '\x99', '\x3', 
		'\x2', '\x2', '\x2', '\x99', '\x9A', '\x3', '\x2', '\x2', '\x2', '\x9A', 
		'\x9B', '\a', '$', '\x2', '\x2', '\x9B', '\x15', '\x3', '\x2', '\x2', 
		'\x2', '\x9C', '\x9D', '\t', '\x2', '\x2', '\x2', '\x9D', '\x17', '\x3', 
		'\x2', '\x2', '\x2', '\x9E', '\xA8', '\x5', '\x1C', '\xF', '\x2', '\x9F', 
		'\xA8', '\x5', '\x1E', '\x10', '\x2', '\xA0', '\xA8', '\x5', '\xE', '\b', 
		'\x2', '\xA1', '\xA8', '\x5', '\x10', '\t', '\x2', '\xA2', '\xA8', '\x5', 
		'\x12', '\n', '\x2', '\xA3', '\xA8', '\x5', '\x14', '\v', '\x2', '\xA4', 
		'\xA8', '\a', '\xE', '\x2', '\x2', '\xA5', '\xA8', '\a', '\x19', '\x2', 
		'\x2', '\xA6', '\xA8', '\a', '!', '\x2', '\x2', '\xA7', '\x9E', '\x3', 
		'\x2', '\x2', '\x2', '\xA7', '\x9F', '\x3', '\x2', '\x2', '\x2', '\xA7', 
		'\xA0', '\x3', '\x2', '\x2', '\x2', '\xA7', '\xA1', '\x3', '\x2', '\x2', 
		'\x2', '\xA7', '\xA2', '\x3', '\x2', '\x2', '\x2', '\xA7', '\xA3', '\x3', 
		'\x2', '\x2', '\x2', '\xA7', '\xA4', '\x3', '\x2', '\x2', '\x2', '\xA7', 
		'\xA5', '\x3', '\x2', '\x2', '\x2', '\xA7', '\xA6', '\x3', '\x2', '\x2', 
		'\x2', '\xA8', '\x19', '\x3', '\x2', '\x2', '\x2', '\xA9', '\xAA', '\x5', 
		' ', '\x11', '\x2', '\xAA', '\xAB', '\a', '\x1A', '\x2', '\x2', '\xAB', 
		'\xAC', '\x5', ' ', '\x11', '\x2', '\xAC', '\xB0', '\x3', '\x2', '\x2', 
		'\x2', '\xAD', '\xB0', '\x5', '\x1C', '\xF', '\x2', '\xAE', '\xB0', '\x5', 
		' ', '\x11', '\x2', '\xAF', '\xA9', '\x3', '\x2', '\x2', '\x2', '\xAF', 
		'\xAD', '\x3', '\x2', '\x2', '\x2', '\xAF', '\xAE', '\x3', '\x2', '\x2', 
		'\x2', '\xB0', '\x1B', '\x3', '\x2', '\x2', '\x2', '\xB1', '\xB2', '\t', 
		'\x3', '\x2', '\x2', '\xB2', '\x1D', '\x3', '\x2', '\x2', '\x2', '\xB3', 
		'\xB6', '\x5', '\"', '\x12', '\x2', '\xB4', '\xB6', '\a', '\x18', '\x2', 
		'\x2', '\xB5', '\xB3', '\x3', '\x2', '\x2', '\x2', '\xB5', '\xB4', '\x3', 
		'\x2', '\x2', '\x2', '\xB6', '\x1F', '\x3', '\x2', '\x2', '\x2', '\xB7', 
		'\xC3', '\x5', '\"', '\x12', '\x2', '\xB8', '\xC3', '\a', '\xE', '\x2', 
		'\x2', '\xB9', '\xC3', '\a', '\x17', '\x2', '\x2', '\xBA', '\xC3', '\a', 
		'\x19', '\x2', '\x2', '\xBB', '\xC3', '\a', '\x1B', '\x2', '\x2', '\xBC', 
		'\xC3', '\a', '\x1C', '\x2', '\x2', '\xBD', '\xC3', '\a', '\x1D', '\x2', 
		'\x2', '\xBE', '\xC3', '\a', '!', '\x2', '\x2', '\xBF', '\xC3', '\a', 
		'\"', '\x2', '\x2', '\xC0', '\xC3', '\a', '#', '\x2', '\x2', '\xC1', '\xC3', 
		'\a', '$', '\x2', '\x2', '\xC2', '\xB7', '\x3', '\x2', '\x2', '\x2', '\xC2', 
		'\xB8', '\x3', '\x2', '\x2', '\x2', '\xC2', '\xB9', '\x3', '\x2', '\x2', 
		'\x2', '\xC2', '\xBA', '\x3', '\x2', '\x2', '\x2', '\xC2', '\xBB', '\x3', 
		'\x2', '\x2', '\x2', '\xC2', '\xBC', '\x3', '\x2', '\x2', '\x2', '\xC2', 
		'\xBD', '\x3', '\x2', '\x2', '\x2', '\xC2', '\xBE', '\x3', '\x2', '\x2', 
		'\x2', '\xC2', '\xBF', '\x3', '\x2', '\x2', '\x2', '\xC2', '\xC0', '\x3', 
		'\x2', '\x2', '\x2', '\xC2', '\xC1', '\x3', '\x2', '\x2', '\x2', '\xC3', 
		'!', '\x3', '\x2', '\x2', '\x2', '\xC4', '\xDF', '\x5', '&', '\x14', '\x2', 
		'\xC5', '\xDF', '\x5', '\x36', '\x1C', '\x2', '\xC6', '\xDF', '\x5', ',', 
		'\x17', '\x2', '\xC7', '\xDF', '\a', '\x5', '\x2', '\x2', '\xC8', '\xDF', 
		'\a', '\a', '\x2', '\x2', '\xC9', '\xDF', '\a', '\b', '\x2', '\x2', '\xCA', 
		'\xDF', '\a', '\t', '\x2', '\x2', '\xCB', '\xDF', '\a', '\n', '\x2', '\x2', 
		'\xCC', '\xDF', '\a', '\v', '\x2', '\x2', '\xCD', '\xDF', '\a', '\r', 
		'\x2', '\x2', '\xCE', '\xDF', '\a', '\x3', '\x2', '\x2', '\xCF', '\xDF', 
		'\a', '\x4', '\x2', '\x2', '\xD0', '\xDF', '\a', '\x1E', '\x2', '\x2', 
		'\xD1', '\xDF', '\a', '\x1F', '\x2', '\x2', '\xD2', '\xDF', '\a', ' ', 
		'\x2', '\x2', '\xD3', '\xDF', '\a', '\x1A', '\x2', '\x2', '\xD4', '\xDF', 
		'\a', '%', '\x2', '\x2', '\xD5', '\xDF', '\a', '&', '\x2', '\x2', '\xD6', 
		'\xDF', '\a', '\'', '\x2', '\x2', '\xD7', '\xDF', '\a', '(', '\x2', '\x2', 
		'\xD8', '\xDF', '\a', ')', '\x2', '\x2', '\xD9', '\xDF', '\a', '*', '\x2', 
		'\x2', '\xDA', '\xDF', '\a', '+', '\x2', '\x2', '\xDB', '\xDF', '\a', 
		',', '\x2', '\x2', '\xDC', '\xDF', '\a', '-', '\x2', '\x2', '\xDD', '\xDF', 
		'\a', 'l', '\x2', '\x2', '\xDE', '\xC4', '\x3', '\x2', '\x2', '\x2', '\xDE', 
		'\xC5', '\x3', '\x2', '\x2', '\x2', '\xDE', '\xC6', '\x3', '\x2', '\x2', 
		'\x2', '\xDE', '\xC7', '\x3', '\x2', '\x2', '\x2', '\xDE', '\xC8', '\x3', 
		'\x2', '\x2', '\x2', '\xDE', '\xC9', '\x3', '\x2', '\x2', '\x2', '\xDE', 
		'\xCA', '\x3', '\x2', '\x2', '\x2', '\xDE', '\xCB', '\x3', '\x2', '\x2', 
		'\x2', '\xDE', '\xCC', '\x3', '\x2', '\x2', '\x2', '\xDE', '\xCD', '\x3', 
		'\x2', '\x2', '\x2', '\xDE', '\xCE', '\x3', '\x2', '\x2', '\x2', '\xDE', 
		'\xCF', '\x3', '\x2', '\x2', '\x2', '\xDE', '\xD0', '\x3', '\x2', '\x2', 
		'\x2', '\xDE', '\xD1', '\x3', '\x2', '\x2', '\x2', '\xDE', '\xD2', '\x3', 
		'\x2', '\x2', '\x2', '\xDE', '\xD3', '\x3', '\x2', '\x2', '\x2', '\xDE', 
		'\xD4', '\x3', '\x2', '\x2', '\x2', '\xDE', '\xD5', '\x3', '\x2', '\x2', 
		'\x2', '\xDE', '\xD6', '\x3', '\x2', '\x2', '\x2', '\xDE', '\xD7', '\x3', 
		'\x2', '\x2', '\x2', '\xDE', '\xD8', '\x3', '\x2', '\x2', '\x2', '\xDE', 
		'\xD9', '\x3', '\x2', '\x2', '\x2', '\xDE', '\xDA', '\x3', '\x2', '\x2', 
		'\x2', '\xDE', '\xDB', '\x3', '\x2', '\x2', '\x2', '\xDE', '\xDC', '\x3', 
		'\x2', '\x2', '\x2', '\xDE', '\xDD', '\x3', '\x2', '\x2', '\x2', '\xDF', 
		'#', '\x3', '\x2', '\x2', '\x2', '\xE0', '\xE1', '\x5', '*', '\x16', '\x2', 
		'\xE1', '%', '\x3', '\x2', '\x2', '\x2', '\xE2', '\xE3', '\a', '\f', '\x2', 
		'\x2', '\xE3', '\xE4', '\t', '\x4', '\x2', '\x2', '\xE4', '\xE5', '\x5', 
		'(', '\x15', '\x2', '\xE5', '\xE6', '\x5', '(', '\x15', '\x2', '\xE6', 
		'\xEC', '\x3', '\x2', '\x2', '\x2', '\xE7', '\xE8', '\a', '\f', '\x2', 
		'\x2', '\xE8', '\xE9', '\x5', '(', '\x15', '\x2', '\xE9', '\xEA', '\x5', 
		'(', '\x15', '\x2', '\xEA', '\xEC', '\x3', '\x2', '\x2', '\x2', '\xEB', 
		'\xE2', '\x3', '\x2', '\x2', '\x2', '\xEB', '\xE7', '\x3', '\x2', '\x2', 
		'\x2', '\xEC', '\'', '\x3', '\x2', '\x2', '\x2', '\xED', '\xEE', '\t', 
		'\x5', '\x2', '\x2', '\xEE', ')', '\x3', '\x2', '\x2', '\x2', '\xEF', 
		'\xF1', '\x5', ',', '\x17', '\x2', '\xF0', '\xEF', '\x3', '\x2', '\x2', 
		'\x2', '\xF1', '\xF2', '\x3', '\x2', '\x2', '\x2', '\xF2', '\xF0', '\x3', 
		'\x2', '\x2', '\x2', '\xF2', '\xF3', '\x3', '\x2', '\x2', '\x2', '\xF3', 
		'+', '\x3', '\x2', '\x2', '\x2', '\xF4', '\xF5', '\t', '\x6', '\x2', '\x2', 
		'\xF5', '-', '\x3', '\x2', '\x2', '\x2', '\xF6', '\xF7', '\x5', '\x30', 
		'\x19', '\x2', '\xF7', '/', '\x3', '\x2', '\x2', '\x2', '\xF8', '\xFB', 
		'\x5', '\x36', '\x1C', '\x2', '\xF9', '\xFB', '\a', '(', '\x2', '\x2', 
		'\xFA', '\xF8', '\x3', '\x2', '\x2', '\x2', '\xFA', '\xF9', '\x3', '\x2', 
		'\x2', '\x2', '\xFB', '\x101', '\x3', '\x2', '\x2', '\x2', '\xFC', '\x100', 
		'\x5', '\x36', '\x1C', '\x2', '\xFD', '\x100', '\a', '(', '\x2', '\x2', 
		'\xFE', '\x100', '\x5', ',', '\x17', '\x2', '\xFF', '\xFC', '\x3', '\x2', 
		'\x2', '\x2', '\xFF', '\xFD', '\x3', '\x2', '\x2', '\x2', '\xFF', '\xFE', 
		'\x3', '\x2', '\x2', '\x2', '\x100', '\x103', '\x3', '\x2', '\x2', '\x2', 
		'\x101', '\xFF', '\x3', '\x2', '\x2', '\x2', '\x101', '\x102', '\x3', 
		'\x2', '\x2', '\x2', '\x102', '\x31', '\x3', '\x2', '\x2', '\x2', '\x103', 
		'\x101', '\x3', '\x2', '\x2', '\x2', '\x104', '\x106', '\x5', '\x34', 
		'\x1B', '\x2', '\x105', '\x104', '\x3', '\x2', '\x2', '\x2', '\x106', 
		'\x107', '\x3', '\x2', '\x2', '\x2', '\x107', '\x105', '\x3', '\x2', '\x2', 
		'\x2', '\x107', '\x108', '\x3', '\x2', '\x2', '\x2', '\x108', '\x33', 
		'\x3', '\x2', '\x2', '\x2', '\x109', '\x10A', '\n', '\a', '\x2', '\x2', 
		'\x10A', '\x35', '\x3', '\x2', '\x2', '\x2', '\x10B', '\x10C', '\t', '\b', 
		'\x2', '\x2', '\x10C', '\x37', '\x3', '\x2', '\x2', '\x2', '\x17', '@', 
		'\x46', 'K', '\x65', 'j', 'q', 'y', '}', '\x8B', '\x98', '\xA7', '\xAF', 
		'\xB5', '\xC2', '\xDE', '\xEB', '\xF2', '\xFA', '\xFF', '\x101', '\x107',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
